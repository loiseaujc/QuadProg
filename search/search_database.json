var tipuesearch = {"pages":[{"title":" QuadProg ","text":"QuadProg Warning This API documentation for the Modern QuadProg pacakge is a work in progress.\n   It is build from the source code in the main branch and does not track the current development in dev or any other branches.\n   If you use another branch, please refer to the in-code documentation.\n   Use the navigation bar at the top of the screen to browse modules , procedures , source files , etc.\n   The listings near the bootom of the page are incomplete. This is the main API documentation landing page generated by FORD . This documentation is released under the CC-BY-SA license while the Modern QuadProg source code is distribution under the BSD-3 Clause one. Description This is an updated version of the quadprog solver initially written by Berwin A. Turlach in Fortran 77. It can be used to solve strictly convex quadratic programs of the form using an active set method . It is most efficient for small to moderate sized QP described using dense matrices. Updates to the original code include: Sources have been translated from FORTRAN 77 fixed-form to Fortran 90 free-form. All obsolescent features ( goto , etc) have been removed. It is now 100% standard compliant (Fortran 2018). It makes use of derived-type and easy to use interfaces. The qp_problem class is used to defined the quadratic program and solve to compute its solution. Calls to blas functions and subroutines now replace some hand-crafted implementations for improved performances. Calls to lapack subroutines now replace the original functionalities provided by linpack . Utility solvers for non-negative least-squares ( nnls ) and bounded-variables least-squares ( bvls ) are provided. Building QuadProg Fortran Package Manager The library can be built with the Fortran Package Manager fpm using the provided fpm.toml file like so: fpm build --release Only double precision ( real64 ) is currently supported. To use QuadProg within your fpm project, add the following to your fpm.toml file: [dependencies] QuadProg = { git = \"https://github.com/loiseaujc/QuadProg.git\" } Example The following program solves the QP program example use quadprog implicit none integer , parameter :: dp = selected_real_kind ( 15 , 307 ) ! Size of the problem. integer , parameter :: n = 3 ! Quadratic cost. real ( dp ) :: P ( n , n ), q ( n ) ! Inequality constraints. real ( dp ) :: C ( n , n ), d ( n ) ! Convenience types. type ( qp_problem ) :: prob type ( OptimizeResult ) :: solution ! Miscellaneous integer :: i !> Setup the quadratic function.. P = 0.0_dp ; q = [ 0.0_dp , 5.0_dp , 0.0_dp ] do i = 1 , n P ( i , i ) = 1.0_dp enddo !> Setup the inequality constraints. C (:, 1 ) = [ - 4.0_dp , 2.0_dp , 0.0_dp ] C (:, 2 ) = [ - 3.0_dp , 1.0_dp , - 2.0_dp ] C (:, 3 ) = [ 0.0_dp , 0.0_dp , 1.0_dp ] d = [ - 8.0_dp , - 2.0_dp , 0.0_dp ] !> Solve the inequality constrained QP. prob = qp_problem ( P , q , C = C , d = d ) solution = solve ( prob ) if ( solution % success ) then print * , \"x   =\" , solution % x ! Solution of the QP. print * , \"y   =\" , solution % y ! Lagrange multipliers. print * , \"obj =\" , solution % obj ! Objective function. endif end program Licence The original source code was released under the GNU General Public Licence version 2 (GPL-2). Development Development continues on Github . Similar projects quadprog , an equivalent project written in JavaScript. quadprog , an equivalent project written in Rust. quadprog , some R bindings to the original quadprog solver. GoldfarbIdnaniSolver.jl , a port of the original quadprog code in Julia. References D. Goldfarb and A. Idnani (1983). A numerically stable dual method for solving strictly convex quadratic programs. Mathematical Programming, 27, 1-33. Developer Info Jean-Christophe Loiseau","tags":"home","url":"index.html"},{"title":"OptimizeResult – QuadProg ","text":"type, public :: OptimizeResult Components Type Visibility Attributes Name Initial real(kind=dp), public :: obj Objective function evaluated at the minimizer. logical, public :: success Whether the problem has been successfully solved or not. real(kind=dp), public, allocatable :: x (:) Solution of the optimization problem. real(kind=dp), public, allocatable :: y (:) Lagrange multipliers associated to each constraint. Source Code type , public :: OptimizeResult real ( dp ), allocatable :: x (:) !! Solution of the optimization problem. real ( dp ), allocatable :: y (:) !! Lagrange multipliers associated to each constraint. real ( dp ) :: obj !! Objective function evaluated at the minimizer. logical :: success !! Whether the problem has been successfully solved or not. end type OptimizeResult","tags":"","url":"type/optimizeresult.html"},{"title":"compact_qp_problem – QuadProg ","text":"type, public :: compact_qp_problem Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: A (:,:) real(kind=dp), public, allocatable :: C (:,:) real(kind=dp), public, allocatable :: P (:,:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. real(kind=dp), public, allocatable :: b (:) real(kind=dp), public, allocatable :: d (:) integer, public, allocatable :: iamat (:,:) Matrix and vector defining the linear equality constraints A @ x = b using\nits compact representation. integer, public, allocatable :: icmat (:,:) Matrix and vector defining the inequality constraints C @ x >= d using\nits compact representation. integer, public :: ncons integer, public :: neq real(kind=dp), public, allocatable :: q (:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. Constructor public        interface compact_qp_problem private module function initialize_compact_qp_problem(P, q, A, iamat, b, C, icmat, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) integer, intent(in), optional :: iamat (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) integer, intent(in), optional :: icmat (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( compact_qp_problem ) Source Code type , public :: compact_qp_problem real ( dp ), allocatable :: P (:, :), q (:) !! Symmetric positive definite matrix and associated vector defining the !! quadratic form 1/2 x.T @ P @ x - x.T @ q. real ( dp ), allocatable :: A (:, :), b (:) integer , allocatable :: iamat (:, :) !! Matrix and vector defining the linear equality constraints A @ x = b using !! its compact representation. real ( dp ), allocatable :: C (:, :), d (:) integer , allocatable :: icmat (:, :) !! Matrix and vector defining the inequality constraints C @ x >= d using !! its compact representation. integer :: neq , ncons end type compact_qp_problem","tags":"","url":"type/compact_qp_problem.html"},{"title":"qp_problem – QuadProg ","text":"type, public :: qp_problem Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: A (:,:) Matrix and vector defining the lineear equality constraints A @ x = b. real(kind=dp), public, allocatable :: C (:,:) Matrix and vector defining the inequality constraints C @ x >= d. real(kind=dp), public, allocatable :: P (:,:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. real(kind=dp), public, allocatable :: b (:) Matrix and vector defining the lineear equality constraints A @ x = b. real(kind=dp), public, allocatable :: d (:) Matrix and vector defining the inequality constraints C @ x >= d. integer, public :: ncons integer, public :: neq real(kind=dp), public, allocatable :: q (:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. Constructor public        interface qp_problem Description Creates an instance of the following strictly convex quadratic program Syntax problem = qp_problem ( P , q , [ A = A , b = b ], [ C = C , d = d ]) Arguments P :   Symmetric positive definite matrix of size n x n . It is an intent(in) argument. q :   Rank-1 array of size n . It is an intent(in) argument. A (optional)    :   Matrix of size m x n defining the equality constraints.\n                        It is an intent(in) argument. b (optional)    :   Rank-1 array of size m defining the right-hand side of\n                        the equality constraints. It is an intent(in) argument. C (optional)    :   Matrix of size p x n defining the inequality constraints.\n                        It is an intent(in) argument. d (optional)    :   Rank-1 array of size p defining the right-hand side of the\n                        inequality constraints. It is an intent(in) argument. private module function initialize_qp_problem(P, q, A, b, C, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( qp_problem ) Source Code type , public :: qp_problem real ( dp ), allocatable :: P (:, :), q (:) !! Symmetric positive definite matrix and associated vector defining the !! quadratic form 1/2 x.T @ P @ x - x.T @ q. real ( dp ), allocatable :: A (:, :), b (:) !! Matrix and vector defining the lineear equality constraints A @ x = b. real ( dp ), allocatable :: C (:, :), d (:) !! Matrix and vector defining the inequality constraints C @ x >= d. integer :: neq , ncons end type qp_problem","tags":"","url":"type/qp_problem.html"},{"title":"bvls – QuadProg","text":"interface Description Solve the bounded least-squares problem Syntax call bvls ( A , b [, ub ] [, lb ]) Arguments A :   Matrix of size m x n with m >= n . It is an intent(in) argument. b :   Rank-1 array of size m . It is an intent(in) argument. lb (optional)   :   Rank-1 array of size n defining the lower bounds for the\n                        solution of the problem. It is an intent(in) argument. ub (optional)   :   Rank-1 array of size n defining the upper bounds for the\n                        solution of the problem. It is an intent(in) argument. public module function bvls(A, b, ub, lb) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(in) :: b (:) real(kind=dp), intent(in), optional :: ub (:) real(kind=dp), intent(in), optional :: lb (:) Return Value real(kind=dp),allocatable,(:)","tags":"","url":"interface/bvls.html"},{"title":"compact_qp_problem – QuadProg","text":"public interface compact_qp_problem Functions private module function initialize_compact_qp_problem(P, q, A, iamat, b, C, icmat, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) integer, intent(in), optional :: iamat (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) integer, intent(in), optional :: icmat (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( compact_qp_problem )","tags":"","url":"interface/compact_qp_problem.html"},{"title":"nnls – QuadProg","text":"interface Description Solve the non-negative least-squares problem Syntax x = nnls ( A , b ) Arguments A :   Matrix of size m x n , with m >= n . It is an intent(in) argument. b :   Rank-1 array of size m . It is an intent(in) argument. x :   Rank-1 array of size n returned by the function. It contains the\n            non-negative coefficients of the least-squares fit. public module function nnls(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(in) :: b (:) Return Value real(kind=dp),allocatable,(:)","tags":"","url":"interface/nnls.html"},{"title":"qp_problem – QuadProg","text":"public interface qp_problem Description Creates an instance of the following strictly convex quadratic program Syntax problem = qp_problem ( P , q , [ A = A , b = b ], [ C = C , d = d ]) Arguments P :   Symmetric positive definite matrix of size n x n . It is an intent(in) argument. q :   Rank-1 array of size n . It is an intent(in) argument. A (optional)    :   Matrix of size m x n defining the equality constraints.\n                        It is an intent(in) argument. b (optional)    :   Rank-1 array of size m defining the right-hand side of\n                        the equality constraints. It is an intent(in) argument. C (optional)    :   Matrix of size p x n defining the inequality constraints.\n                        It is an intent(in) argument. d (optional)    :   Rank-1 array of size p defining the right-hand side of the\n                        inequality constraints. It is an intent(in) argument. Functions private module function initialize_qp_problem(P, q, A, b, C, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( qp_problem )","tags":"","url":"interface/qp_problem.html"},{"title":"solve – QuadProg","text":"public interface solve Description Solve a strictly convex quadratic program of the form using a primal-dual active set method. The matrix $P \\in \\mathbb{R}&#94;{n \\times n}$\nneeds to be symmetric positive definite. References D. Goldfarb and A. Idnani (1983). A numerically stable dual method for solving\n  strictly convex quadratic programs. Mathematical Programming, 27, 1-33. Syntax result = solve ( problem ) Arguments problem :   Derived-type qp_problem or compact_qp_problem describing the\n                quadratic program to be solved. It is an intent(in) argument. result :   Derived-type OptimizeResult containing the solution of the problem,\n                the associated vector of Lagrange multipliers and the value of the\n                objective function at the constrained solution. Functions private module function solve_compact_qp(problem) result(result) Arguments Type Intent Optional Attributes Name type( compact_qp_problem ), intent(in) :: problem Return Value type( OptimizeResult ) private module function solve_standard_qp(problem) result(result) Arguments Type Intent Optional Attributes Name type( qp_problem ), intent(in) :: problem Return Value type( OptimizeResult )","tags":"","url":"interface/solve.html"},{"title":"quadprog_constants – QuadProg","text":"Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: atol = 10.0_dp**(-precision(1.0_dp)) integer, public, parameter :: dp = selected_real_kind(15, 307) real(kind=dp), public, parameter :: eps = epsilon(1.0_dp) real(kind=dp), public, parameter :: rtol = sqrt(atol)","tags":"","url":"module/quadprog_constants.html"},{"title":"QuadProg – QuadProg","text":"Uses stdlib_linalg_lapack stdlib_linalg assert_m quadprog_constants stdlib_linalg_blas stdlib_intrinsics Used by Descendants: lstsq_variants modernized_drivers Interfaces interface Description Solve the bounded least-squares problem Syntax call bvls ( A , b [, ub ] [, lb ]) Arguments A :   Matrix of size m x n with m >= n . It is an intent(in) argument. b :   Rank-1 array of size m . It is an intent(in) argument. lb (optional)   :   Rank-1 array of size n defining the lower bounds for the\n                        solution of the problem. It is an intent(in) argument. ub (optional)   :   Rank-1 array of size n defining the upper bounds for the\n                        solution of the problem. It is an intent(in) argument. public module function bvls(A, b, ub, lb) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(in) :: b (:) real(kind=dp), intent(in), optional :: ub (:) real(kind=dp), intent(in), optional :: lb (:) Return Value real(kind=dp), allocatable, (:) public        interface compact_qp_problem private module function initialize_compact_qp_problem(P, q, A, iamat, b, C, icmat, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) integer, intent(in), optional :: iamat (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) integer, intent(in), optional :: icmat (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( compact_qp_problem ) interface Description Solve the non-negative least-squares problem Syntax x = nnls ( A , b ) Arguments A :   Matrix of size m x n , with m >= n . It is an intent(in) argument. b :   Rank-1 array of size m . It is an intent(in) argument. x :   Rank-1 array of size n returned by the function. It contains the\n            non-negative coefficients of the least-squares fit. public module function nnls(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(in) :: b (:) Return Value real(kind=dp), allocatable, (:) public        interface qp_problem Description Creates an instance of the following strictly convex quadratic program Syntax problem = qp_problem ( P , q , [ A = A , b = b ], [ C = C , d = d ]) Arguments P :   Symmetric positive definite matrix of size n x n . It is an intent(in) argument. q :   Rank-1 array of size n . It is an intent(in) argument. A (optional)    :   Matrix of size m x n defining the equality constraints.\n                        It is an intent(in) argument. b (optional)    :   Rank-1 array of size m defining the right-hand side of\n                        the equality constraints. It is an intent(in) argument. C (optional)    :   Matrix of size p x n defining the inequality constraints.\n                        It is an intent(in) argument. d (optional)    :   Rank-1 array of size p defining the right-hand side of the\n                        inequality constraints. It is an intent(in) argument. private module function initialize_qp_problem(P, q, A, b, C, d) result(prob) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: P (:,:) real(kind=dp), intent(in) :: q (:) real(kind=dp), intent(in), optional :: A (:,:) real(kind=dp), intent(in), optional :: b (:) real(kind=dp), intent(in), optional :: C (:,:) real(kind=dp), intent(in), optional :: d (:) Return Value type( qp_problem ) public        interface solve Description Solve a strictly convex quadratic program of the form using a primal-dual active set method. The matrix $P \\in \\mathbb{R}&#94;{n \\times n}$\nneeds to be symmetric positive definite. References D. Goldfarb and A. Idnani (1983). A numerically stable dual method for solving\n  strictly convex quadratic programs. Mathematical Programming, 27, 1-33. Syntax result = solve ( problem ) Arguments problem :   Derived-type qp_problem or compact_qp_problem describing the\n                quadratic program to be solved. It is an intent(in) argument. result :   Derived-type OptimizeResult containing the solution of the problem,\n                the associated vector of Lagrange multipliers and the value of the\n                objective function at the constrained solution. private module function solve_compact_qp(problem) result(result) Arguments Type Intent Optional Attributes Name type( compact_qp_problem ), intent(in) :: problem Return Value type( OptimizeResult ) private module function solve_standard_qp(problem) result(result) Arguments Type Intent Optional Attributes Name type( qp_problem ), intent(in) :: problem Return Value type( OptimizeResult ) Derived Types type, public :: OptimizeResult Components Type Visibility Attributes Name Initial real(kind=dp), public :: obj Objective function evaluated at the minimizer. logical, public :: success Whether the problem has been successfully solved or not. real(kind=dp), public, allocatable :: x (:) Solution of the optimization problem. real(kind=dp), public, allocatable :: y (:) Lagrange multipliers associated to each constraint. type, public :: compact_qp_problem Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: A (:,:) real(kind=dp), public, allocatable :: C (:,:) real(kind=dp), public, allocatable :: P (:,:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. real(kind=dp), public, allocatable :: b (:) real(kind=dp), public, allocatable :: d (:) integer, public, allocatable :: iamat (:,:) Matrix and vector defining the linear equality constraints A @ x = b using\nits compact representation. integer, public, allocatable :: icmat (:,:) Matrix and vector defining the inequality constraints C @ x >= d using\nits compact representation. integer, public :: ncons integer, public :: neq real(kind=dp), public, allocatable :: q (:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. Constructor private\n\n                    module\n                    function initialize_compact_qp_problem (P, q, A, iamat, b, C, icmat, d) type, public :: qp_problem Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: A (:,:) Matrix and vector defining the lineear equality constraints A @ x = b. real(kind=dp), public, allocatable :: C (:,:) Matrix and vector defining the inequality constraints C @ x >= d. real(kind=dp), public, allocatable :: P (:,:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. real(kind=dp), public, allocatable :: b (:) Matrix and vector defining the lineear equality constraints A @ x = b. real(kind=dp), public, allocatable :: d (:) Matrix and vector defining the inequality constraints C @ x >= d. integer, public :: ncons integer, public :: neq real(kind=dp), public, allocatable :: q (:) Symmetric positive definite matrix and associated vector defining the\nquadratic form 1/2 x.T @ P @ x - x.T @ q. Constructor Creates an instance of the following strictly convex quadratic program Read more… private\n\n                    module\n                    function initialize_qp_problem (P, q, A, b, C, d)","tags":"","url":"module/quadprog.html"},{"title":"lstsq_variants – QuadProg","text":"Uses quadprog_constants Ancestors: QuadProg","tags":"","url":"module/lstsq_variants.html"},{"title":"modernized_drivers – QuadProg","text":"Uses Ancestors: QuadProg","tags":"","url":"module/modernized_drivers.html"},{"title":"constants.f90 – QuadProg","text":"Source Code module quadprog_constants implicit none ( type , external ) private integer , parameter , public :: dp = selected_real_kind ( 15 , 307 ) real ( dp ), parameter , public :: atol = 1 0.0_dp ** ( - precision ( 1.0_dp )) real ( dp ), parameter , public :: rtol = sqrt ( atol ) real ( dp ), parameter , public :: eps = epsilon ( 1.0_dp ) end module quadprog_constants","tags":"","url":"sourcefile/constants.f90.html"},{"title":"QuadProg.f90 – QuadProg","text":"Source Code module QuadProg use quadprog_constants , only : dp use stdlib_linalg , only : cholesky , norm , qr , linalg_state_type use stdlib_linalg_blas , only : scal , axpy , copy , swap , & trmv , gemv , tpsv , rot use stdlib_linalg_lapack , only : trtri , potrs , lartg , & geqrf , orgqr use stdlib_intrinsics , only : dot_product => stdlib_dot_product use assert_m , only : assert => assert_always implicit none private public :: dp public :: solve public :: nnls , bvls !--------------------------------- !-----     DERIVED-TYPES     ----- !--------------------------------- type , public :: OptimizeResult real ( dp ), allocatable :: x (:) !! Solution of the optimization problem. real ( dp ), allocatable :: y (:) !! Lagrange multipliers associated to each constraint. real ( dp ) :: obj !! Objective function evaluated at the minimizer. logical :: success !! Whether the problem has been successfully solved or not. end type OptimizeResult type , public :: qp_problem real ( dp ), allocatable :: P (:, :), q (:) !! Symmetric positive definite matrix and associated vector defining the !! quadratic form 1/2 x.T @ P @ x - x.T @ q. real ( dp ), allocatable :: A (:, :), b (:) !! Matrix and vector defining the lineear equality constraints A @ x = b. real ( dp ), allocatable :: C (:, :), d (:) !! Matrix and vector defining the inequality constraints C @ x >= d. integer :: neq , ncons end type qp_problem interface qp_problem !!    ### Description !! !!    Creates an instance of the following strictly convex quadratic program !! !!     !!        \\begin{aligned} !!            \\mathrm{minimize}   &   \\quad   \\dfrac12 x&#94;\\top P x - x&#94;\\top q \\\\ !!            \\mathrm{subject~to} &   \\quad   Ax = b \\\\ !!                                &   \\quad   Cx \\geq d !!        \\end{aligned} !!     !! !! !!    ### Syntax !! !!    ```fortran !!        problem = qp_problem(P, q, [A=A, b=b], [C=C, d=d]) !!    ``` !! !!    ### Arguments !! !!    - `P`   :   Symmetric positive definite matrix of size `n x n`. It is an `intent(in)` !!                argument. !! !!    - `q`   :   Rank-1 array of size `n`. It is an `intent(in)` argument. !! !!    - `A` (optional)    :   Matrix of size `m x n` defining the equality constraints. !!                            It is an `intent(in)` argument. !! !!    - `b` (optional)    :   Rank-1 array of size `m` defining the right-hand side of !!                            the equality constraints. It is an `intent(in)` argument. !! !!    - `C` (optional)    :   Matrix of size `p x n` defining the inequality constraints. !!                            It is an `intent(in)` argument. !! !!    - `d` (optional)    :   Rank-1 array of size `p` defining the right-hand side of the !!                            inequality constraints. It is an `intent(in)` argument. module type ( qp_problem ) function initialize_qp_problem ( P , q , A , b , C , d ) result ( prob ) implicit none real ( dp ), intent ( in ) :: P (:, :), q (:) real ( dp ), optional , intent ( in ) :: A (:, :), b (:) real ( dp ), optional , intent ( in ) :: C (:, :), d (:) end function initialize_qp_problem end interface type , public :: compact_qp_problem real ( dp ), allocatable :: P (:, :), q (:) !! Symmetric positive definite matrix and associated vector defining the !! quadratic form 1/2 x.T @ P @ x - x.T @ q. real ( dp ), allocatable :: A (:, :), b (:) integer , allocatable :: iamat (:, :) !! Matrix and vector defining the linear equality constraints A @ x = b using !! its compact representation. real ( dp ), allocatable :: C (:, :), d (:) integer , allocatable :: icmat (:, :) !! Matrix and vector defining the inequality constraints C @ x >= d using !! its compact representation. integer :: neq , ncons end type compact_qp_problem interface compact_qp_problem module type ( compact_qp_problem ) function initialize_compact_qp_problem ( P , q , A , iamat , b , & C , icmat , d ) result ( prob ) implicit none real ( dp ), intent ( in ) :: P (:, :), q (:) real ( dp ), optional , intent ( in ) :: A (:, :), b (:) integer , optional , intent ( in ) :: iamat (:, :) real ( dp ), optional , intent ( in ) :: C (:, :), d (:) integer , optional , intent ( in ) :: icmat (:, :) end function initialize_compact_qp_problem end interface !--------------------------------------------------- !-----     INTERFACE FOR SOLVE(QP_PROBLEM)     ----- !--------------------------------------------------- interface solve !!    ### Description !! !!    Solve a strictly convex quadratic program of the form !! !!     !!        \\begin{aligned} !!            \\mathrm{minimize}   &   \\quad   \\dfrac12 x&#94;\\top P x - x&#94;\\top q \\\\ !!            \\mathrm{subject~to} &   \\quad   Ax = b \\\\ !!                                &   \\quad   Cx \\geq d !!        \\end{aligned} !!     !! !!    using a primal-dual active set method. The matrix $P \\in \\mathbb{R}&#94;{n \\times n}$ !!    needs to be symmetric positive definite. !! !!    **References** !! !!    - D. Goldfarb and A. Idnani (1983). A numerically stable dual method for solving !!      strictly convex quadratic programs. Mathematical Programming, 27, 1-33. !! !!    ### Syntax !! !!    ```fortran !!        result = solve(problem) !!    ``` !! !!    ### Arguments !! !!    - `problem` :   Derived-type `qp_problem` or `compact_qp_problem` describing the !!                    quadratic program to be solved. It is an `intent(in)` argument. !! !!    - `result`  :   Derived-type `OptimizeResult` containing the solution of the problem, !!                    the associated vector of Lagrange multipliers and the value of the !!                    objective function at the constrained solution. module type ( OptimizeResult ) function solve_standard_qp ( problem ) result ( result ) implicit none type ( qp_problem ), intent ( in ) :: problem end function solve_standard_qp module type ( OptimizeResult ) function solve_compact_qp ( problem ) result ( result ) implicit none type ( compact_qp_problem ), intent ( in ) :: problem end function solve_compact_qp end interface !------------------------------------------------------------------ !-----     INTERFACES FOR THE QUADPROG MODERNIZED DRIVERS     ----- !------------------------------------------------------------------ interface module subroutine qpgen1 ( dmat , dvec , fddmat , n , sol , lagr , crval , amat , iamat , bvec , & fdamat , q , meq , iact , nact , iter , work , ierr ) implicit none integer , intent ( in ) :: fddmat , n !! Dimensions of the symmetric positive definit matrix Dmat. integer , intent ( in ) :: fdamat , q !! Dimensions of the constraints matrix Amat. integer , intent ( in ) :: meq !! Number of equality constraints. integer , intent ( out ) :: iact ( * ), nact !! Indices and number of active constraints at the optimum. integer , intent ( out ) :: iter ( * ) !! Number of iterations. integer , intent ( inout ) :: ierr !! Information flag. real ( dp ), intent ( inout ) :: dmat ( fddmat , * ), dvec ( * ) !! Sym. pos. def. matrix and vector defining the quadratic cost. real ( dp ), intent ( out ) :: lagr ( * ), sol ( * ) !! Lagrange multipliers and solution vector. integer , intent ( in ) :: iamat ( fdamat + 1 , * ) real ( dp ), intent ( inout ) :: amat ( fdamat , * ), bvec ( * ) !! Matrix and vector defining the (in-)equality constraints. real ( dp ), intent ( inout ) :: work ( * ) !! Workspace. real ( dp ), intent ( out ) :: crval !! Cost function at the optimum. end subroutine qpgen1 module subroutine qpgen2 ( P , q , At , b , meq , x , y , obj , & iact , nact , iter , work , ierr ) implicit none integer , intent ( in ) :: meq !! Number of equality constraints. integer , intent ( out ) :: iact (:), nact !! Indices and number of active constraints at the optimum. integer , intent ( out ) :: iter ( 2 ) !! Number of iterations. integer , intent ( inout ) :: ierr !! Information flag. real ( dp ), intent ( inout ) :: P (:, :), q (:) !! Sym. pos. def. matrix and vector defining the quadratic cost. real ( dp ), intent ( out ) :: y (:), x (:) !! Lagrange multipliers and solution vector. real ( dp ), intent ( inout ) :: At (:, :), b (:) !! Matrix and vector defining the (in-)equality constraints. real ( dp ), intent ( inout ) :: work (:) !! Workspace. real ( dp ), intent ( out ) :: obj !! Cost function at the optimum. end subroutine qpgen2 end interface !------------------------------------------------------------------------ !-----     INTERFACES FOR THE VARIANTS OF LEAST-SQUARES SOLVERS     ----- !------------------------------------------------------------------------ interface !!    ### Description !! !!    Solve the non-negative least-squares problem !! !!     !!        \\begin{aligned} !!            \\mathrm{minimize}   &   \\quad   \\| Ax - b \\|_2&#94;2 \\\\ !!            \\mathrm{subject~to} &   \\quad   x \\geq 0. !!        \\end{aligned} !!     !! !!    ### Syntax !! !!    ```fortran !!        x = nnls(A, b) !!    ``` !! !!    ### Arguments !! !!    - `A`   :   Matrix of size `m x n`, with `m >= n`. It is an `intent(in)` argument. !! !!    - `b`   :   Rank-1 array of size `m`. It is an `intent(in)` argument. !! !!    - `x`   :   Rank-1 array of size `n` returned by the function. It contains the !!                non-negative coefficients of the least-squares fit. module function nnls ( A , b ) result ( x ) implicit none real ( dp ), intent ( inout ) :: A (:, :) real ( dp ), intent ( in ) :: b (:) real ( dp ), allocatable :: x (:) end function nnls end interface interface !!    ### Description !! !!    Solve the bounded least-squares problem !! !!     !!        \\begin{aligned} !!            \\mathrm{minimize}   &   \\quad   \\| A x - b \\|_2&#94;2 \\\\ !!            \\mathrm{subject~to} &   \\quad   l \\leq x \\leq u !!        \\end{aligned} !!     !! !!    ### Syntax !! !!    ```fortran !!        call bvls(A, b [, ub] [, lb]) !!    ``` !! !!    ### Arguments !! !!    - `A`   :   Matrix of size `m x n` with `m >= n`. It is an `intent(in)` argument. !! !!    - `b`   :   Rank-1 array of size `m`. It is an `intent(in)` argument. !! !!    - `lb` (optional)   :   Rank-1 array of size `n` defining the lower bounds for the !!                            solution of the problem. It is an `intent(in)` argument. !! !!    - `ub` (optional)   :   Rank-1 array of size `n` defining the upper bounds for the !!                            solution of the problem. It is an `intent(in)` argument. module function bvls ( A , b , ub , lb ) result ( x ) implicit none real ( dp ), intent ( inout ) :: A (:, :) real ( dp ), intent ( in ) :: b (:) real ( dp ), optional , intent ( in ) :: ub (:) real ( dp ), optional , intent ( in ) :: lb (:) real ( dp ), allocatable :: x (:) end function bvls end interface contains !--------------------------------------- !-----                             ----- !-----     STANDARD QP PROBLEM     ----- !-----                             ----- !--------------------------------------- module type ( qp_problem ) function initialize_qp_problem ( P , q , A , b , C , d ) result ( prob ) implicit none real ( dp ), intent ( in ) :: P (:, :), q (:) real ( dp ), optional , intent ( in ) :: A (:, :), b (:) real ( dp ), optional , intent ( in ) :: C (:, :), d (:) integer :: info , n prob % neq = 0 ; prob % ncons = 0 !> Sanity checks for the quadratic form. call assert ( assertion = size ( P , 1 ) == size ( P , 2 ), & description = \"Matrix P is not square.\" ) call assert ( assertion = size ( P , 1 ) == size ( q ), & description = \"Matrix P and vector q have incompatible dimensions.\" ) !> Quadratic cost. prob % P = P ; prob % q = q ; n = size ( P , 1 ) !> Pre-factorize the symmetric positive definite matrix. call cholesky ( prob % P , lower = . false ., other_zeroed = . true .) call trtri ( \"u\" , \"n\" , n , prob % P , n , info ) !> Sanity checks for the equality constraints. call assert ( assertion = ( present ( A ) . and . present ( b )) . or . (. not . present ( A ) . and . . not . present ( b )), & description = \"Equality constraints are mis-specified (A or b is missing).\" ) if ( present ( A ) . and . present ( b )) then call assert ( assertion = size ( P , 2 ) == size ( A , 2 ), & description = \"Matrices P and A have incompatible number of columns.\" ) call assert ( assertion = size ( A , 1 ) == size ( b ), & description = \"Matrix A and vector b have incompatible dimensions.\" ) prob % A = A ; prob % b = b ; prob % neq = size ( b ); prob % ncons = size ( b ) end if !> Sanity checks for the inequality constraints. call assert ( assertion = ( present ( C ) . and . present ( d )) . or . (. not . present ( C ) . and . . not . present ( d )), & description = \"Inequality constraints are mis-specified (C or d is missing).\" ) if ( present ( C ) . and . present ( d )) then call assert ( assertion = size ( P , 2 ) == size ( C , 2 ), & description = \"Matrices P and C have incompatible number of columns.\" ) call assert ( assertion = size ( C , 1 ) == size ( d ), & description = \"Matrix C and vector d have incompatible dimensions.\" ) prob % C = C ; prob % d = d ; prob % ncons = prob % neq + size ( d ) end if return end function initialize_qp_problem subroutine get_constraints_matrix ( prob , G , h ) implicit none type ( qp_problem ), intent ( in ) :: prob !! Quadratic Problem to be solved. real ( dp ), allocatable , intent ( out ) :: G (:, :) !! Constraints matrix expected by qpgen2. real ( dp ), allocatable , intent ( out ) :: h (:) !! Constraints vector expected by qpgen2. ! Internal variables. logical :: is_constrained integer :: i associate ( n => size ( prob % P , 1 ), neq => prob % neq , ncons => prob % ncons ) is_constrained = allocated ( prob % A ) . or . allocated ( prob % C ) if ( is_constrained ) then allocate ( G ( n , ncons ), h ( ncons ), source = 0.0_dp ) !> Linear equality constraints. if ( allocated ( prob % A )) then do i = 1 , neq G (:, i ) = prob % A ( i , :); h ( i ) = prob % b ( i ) end do end if !> Linear inequality constraints. if ( allocated ( prob % C )) then do i = neq + 1 , ncons G (:, i ) = prob % C ( i - neq , :); h ( i ) = prob % d ( i - neq ) end do end if else allocate ( G ( 1 , 1 ), h ( 1 ), source = 0.0_dp ) end if end associate return end subroutine get_constraints_matrix module type ( OptimizeResult ) function solve_standard_qp ( problem ) result ( result ) implicit none type ( qp_problem ), intent ( in ) :: problem real ( dp ), allocatable :: P (:, :), q (:) real ( dp ), allocatable :: G (:, :), h (:) real ( dp ), allocatable :: work (:) integer :: n , neq , ncons , r , lwork , nact , iter ( 2 ), info integer , allocatable :: iact (:) n = size ( problem % P , 1 ); neq = problem % neq ; ncons = problem % ncons !> Allocate data. allocate ( iact ( ncons )) allocate ( P , source = problem % P ); allocate ( q , source = problem % q ) allocate ( result % x ( n ), source = q ) allocate ( result % y ( ncons ), source = 0.0_dp ) if ( ncons == 0 ) then !> Solve unconstrained problem. call trmv ( \"u\" , \"t\" , \"n\" , n , P , n , result % x , 1 ) ! Multiply by inv(R).T call trmv ( \"u\" , \"n\" , \"n\" , n , P , n , result % x , 1 ) ! Multiply by inv(R) result % success = . true . else !> Allocate workspace r = min ( n , ncons ); lwork = 2 * n + r * ( r + 5 ) / 2 + 2 * ncons + 1 allocate ( work ( lwork ), source = 0.0_dp ) !> Get the constraints matrix and vector. call get_constraints_matrix ( problem , G , h ) !> Solve the QP problem. info = 1 ! P is already factorized when defining the QP. call qpgen2 ( P , q , G , h , neq , result % x , result % y , result % obj , & iact , nact , iter , work , info ) !> Success? result % success = ( info == 0 ) end if return end function solve_standard_qp !-------------------------------------- !-----                            ----- !-----     COMPACT QP PROBLEM     ----- !-----                            ----- !-------------------------------------- module type ( compact_qp_problem ) function initialize_compact_qp_problem ( P , q , A , iamat , b , & C , icmat , d ) result ( prob ) implicit none real ( dp ), intent ( in ) :: P (:, :), q (:) real ( dp ), optional , intent ( in ) :: A (:, :), b (:) integer , optional , intent ( in ) :: iamat (:, :) real ( dp ), optional , intent ( in ) :: C (:, :), d (:) integer , optional , intent ( in ) :: icmat (:, :) integer :: info , n prob % neq = 0 ; prob % ncons = 0 !> Sanity checks for the quadratic form. if ( size ( P , 1 ) /= size ( P , 2 )) error stop \"Matrix P is not square.\" if ( size ( P , 1 ) /= size ( q )) error stop \"Matrix P and vector q have incompatible dimensions.\" !> Quadratic cost. prob % P = P ; prob % q = q ; n = size ( P , 1 ) !> Pre-factorize the symmetric positive definite matrix. call cholesky ( prob % P , lower = . false ., other_zeroed = . true .) call trtri ( \"u\" , \"n\" , n , prob % P , n , info ) !> Sanity checks for the equality constraints. if ( present ( A ) . and . . not . present ( iamat )) error stop \"Matrix A is provided but not iamat.\" if (. not . present ( A ) . and . present ( iamat )) error stop \"iamat is provided but not matrix A.\" if ( present ( A ) . and . . not . present ( b )) error stop \"Right-hand side vector b for the equality constraints is missing.\" if (. not . present ( A ) . and . present ( b )) error stop \"Matrix A for the equality constraints is missing.\" if ( present ( A ) . and . present ( b ) . and . present ( iamat )) then if ( size ( iamat , 1 ) /= size ( A , 1 ) + 1 ) error stop \"Matrix A and index iamat have incompatible dimensions.\" if ( size ( iamat , 2 ) /= size ( A , 2 )) error stop \"Matrix A and index iamat have incompatible dimensions.\" prob % A = A ; prob % iamat = iamat ; prob % b = b ; prob % neq = size ( b ); prob % ncons = size ( b ) end if !> Sanity checks for the inequality constraints. if ( present ( C ) . and . . not . present ( icmat )) error stop \"Matrix C is provided but not icmat.\" if (. not . present ( C ) . and . present ( icmat )) error stop \"icmat is provided but not matrix C.\" if ( present ( C ) . and . . not . present ( d )) error stop \"Right-hand side vector d for the inequality constraints is missing.\" if (. not . present ( C ) . and . present ( d )) error stop \"Matrix C for the inequality constraints is missing.\" if ( present ( C ) . and . present ( d ) . and . present ( icmat )) then if ( size ( icmat , 1 ) /= size ( C , 1 ) + 1 ) error stop \"Matrix C and index icmat have incompatible dimensions.\" if ( size ( icmat , 2 ) /= size ( C , 2 )) error stop \"Matrix C and index icmat have incompatible dimensions.\" prob % C = C ; prob % icmat = icmat ; prob % d = d ; prob % ncons = prob % neq + size ( d ) end if end function initialize_compact_qp_problem subroutine get_compact_constraints_matrix ( prob , G , igmat , h ) implicit none type ( compact_qp_problem ), intent ( in ) :: prob !! Quadratic Problem to be solved. real ( dp ), allocatable , intent ( out ) :: G (:, :) integer , allocatable , intent ( out ) :: igmat (:, :) !! Constraints matrix expected by qpgen1 (compact representation). real ( dp ), allocatable , intent ( out ) :: h (:) !! Constraints vector expected by qpgen1. ! Internal variables. logical :: is_constrained integer :: ma , na , mc , nc associate ( n => size ( prob % P , 1 ), neq => prob % neq , ncons => prob % ncons ) is_constrained = allocated ( prob % A ) . or . allocated ( prob % C ) if ( is_constrained ) then !> Linear equality constraints. if ( allocated ( prob % A )) then G = prob % A ; igmat = prob % iamat ; h = prob % b end if !> Linear inequality constraints. if ( allocated ( prob % C )) then if ( allocated ( prob % A )) then !> Both equality and inequality constraints. ma = size ( prob % A , 1 ); na = size ( prob % A , 2 ) mc = size ( prob % C , 1 ) allocate ( G ( ma + mc , n )) allocate ( igmat ( ma + mc + 1 , n )) !> Construct the constraint matrix. G (: na , :) = prob % A G ( na + 1 :, :) = prob % C igmat ( 1 , :) = prob % iamat ( 1 , :) + prob % icmat ( 1 , :) igmat ( 2 : na + 1 , :) = prob % iamat igmat ( na + 2 :, :) = prob % icmat else !> Only inequality constraints. G = prob % C ; igmat = prob % icmat ; h = prob % d end if end if else allocate ( G ( 1 , n ), h ( 1 ), source = 0.0_dp ) allocate ( igmat ( 2 , n ), source = 0 ) end if end associate return end subroutine get_compact_constraints_matrix module type ( OptimizeResult ) function solve_compact_qp ( problem ) result ( result ) implicit none type ( compact_qp_problem ), intent ( in ) :: problem real ( dp ), allocatable :: P (:, :), q (:) real ( dp ), allocatable :: G (:, :), h (:) integer , allocatable :: igmat (:, :) real ( dp ), allocatable :: work (:) integer :: n , neq , ncons , r , lwork , nact , iter ( 2 ), info integer , allocatable :: iact (:) n = size ( problem % P , 1 ); neq = problem % neq ; ncons = problem % ncons !> Allocate data. allocate ( iact ( ncons )) allocate ( P , source = problem % P ); allocate ( q , source = problem % q ) allocate ( result % x , mold = q ); result % x = 0.0_dp allocate ( result % y ( ncons ), source = 0.0_dp ) !> Allocate workspace r = min ( n , ncons ); lwork = 2 * n + r * ( r + 5 ) / 2 + 2 * ncons + 1 allocate ( work ( lwork ), source = 0.0_dp ) !> Get the constraints matrix and vector. call get_compact_constraints_matrix ( problem , G , igmat , h ) !> Solve the QP problem. info = 1 ! P is already factorized when defining the QP. call qpgen1 ( P , q , n , n , result % x , result % y , result % obj , G , igmat , h , size ( G , 1 ), & ncons , neq , iact , nact , iter , work , info ) !> Success? result % success = ( info == 0 ) return end function solve_compact_qp end module QuadProg","tags":"","url":"sourcefile/quadprog.f90.html"},{"title":"lstsq_variants.f90 – QuadProg","text":"Source Code submodule ( quadprog ) lstsq_variants use quadprog_constants , only : dp contains !---------------------------------------------- !-----     Non-Negative Least-Squares     ----- !---------------------------------------------- module procedure nnls ! Problem's dimensions. integer :: m , n ! QR factorization. real ( dp ), allocatable :: Q (:, :), R (:, :) ! Constraint matrix. real ( dp ), allocatable :: C (:, :), d (:) integer , allocatable :: icmat (:, :) ! Miscellaneous. integer :: i , info !> Get problem's dimensions. m = size ( A , 1 ); n = size ( A , 2 ) !> Sanity checks. if ( m < n ) error stop \"For m < n, the problem is not strictly convex and cannot be solved with QuadProg.\" if ( size ( b ) /= m ) error stop \"A and b have inconsistent number of rows.\" !> Allocate matrices. allocate ( x ( n ), source = 0.0_dp ) !> Constraint matrix. allocate ( C ( 1 , n ), source = 1.0_dp ) allocate ( d ( n ), source = 0.0_dp ) allocate ( icmat ( 2 , n )); icmat ( 1 , :) = 1 ; icmat ( 2 , :) = [( i , i = 1 , n )] !> QR decomposition of the data matrix. allocate ( Q ( m , n ), source = 0.0_dp ) allocate ( R ( n , n ), source = 0.0_dp ) call qr ( A , Q , R ) !> Compute inv(R). call trtri ( \"u\" , \"n\" , n , R , n , info ) !> Solve the corresponding Quadratic Program. block real ( dp ) :: qvec ( n ), y ( n ), obj real ( dp ), allocatable :: work (:) integer :: neq , ncons , nact , iter ( 2 ), iact ( n ), lwork ! Prepare variables. neq = 0 ; ncons = n ; lwork = 2 * n + n * ( n + 5 ) / 2 + 2 * n + 1 allocate ( work ( lwork ), source = 0.0_dp ) ! Solve QP. info = 1 ; qvec = matmul ( transpose ( A ), b ) call qpgen1 ( R , qvec , n , n , x , y , obj , C , icmat , d , 1 , ncons , & neq , iact , nact , iter , work , info ) end block end procedure nnls !--------------------------------------------------- !-----     Bounded-Variables Least-Squares     ----- !--------------------------------------------------- module procedure bvls ! Problem's dimensions. integer :: m , n ! QR factorization. real ( dp ), allocatable :: Q (:, :), R (:, :) ! Constraint matrix. real ( dp ), allocatable :: C (:, :), d (:) integer , allocatable :: icmat (:, :) ! Miscellaneous. integer :: i , info , ncons logical :: is_upper_bounded , is_lower_bounded !> Get problem's dimensions. m = size ( A , 1 ); n = size ( A , 2 ) !----- Sanity checks ----- !> Sanity checks. if ( m < n ) error stop \"For m < n, the problem is not strictly convex and cannot be solved with QuadProg.\" if ( size ( b ) /= m ) error stop \"A and b have inconsistent number of rows.\" is_upper_bounded = . false . if ( present ( ub )) then if ( size ( ub ) /= n ) error stop \"The number of upper bounds is incompatible with the number of variables.\" is_upper_bounded = . true . end if if ( present ( lb )) then if ( size ( lb ) /= n ) error stop \"The number of lower bounds is incompatible with the number of variables.\" is_lower_bounded = . true . end if if ( is_lower_bounded . and . is_upper_bounded ) then do i = 1 , n if ( lb ( i ) > ub ( i )) error stop \"Some lower bounds are actually larger than the provided upper bounds.\" end do end if !----- Sets up the problem ----- allocate ( x ( n ), source = 0.0_dp ) !> Constraint matrix. if ( is_lower_bounded . and . . not . is_upper_bounded ) then allocate ( C ( 1 , n ), source = 1.0_dp ); allocate ( d , source = lb ) allocate ( icmat ( 2 , n )); icmat ( 1 , :) = 1 ; icmat ( 2 , :) = [( i , i = 1 , n )] ncons = n else if ( is_upper_bounded . and . . not . is_lower_bounded ) then allocate ( C ( 1 , n ), source = 1.0_dp ); allocate ( d , source = ub ) allocate ( icmat ( 2 , n )); icmat ( 1 , :) = 1 ; icmat ( 2 , :) = [( i , i = 1 , n )] ncons = n else if ( is_upper_bounded . and . is_lower_bounded ) then allocate ( C ( 1 , 2 * n ), d ( 2 * n ), icmat ( 2 , 2 * n )) icmat ( 1 , :) = 1 do i = 1 , n icmat ( 2 , i ) = i ; icmat ( 2 , i + n ) = i C ( 1 , i ) = 1.0_dp ; C ( 1 , i + n ) = - 1.0_dp d ( i ) = lb ( i ); d ( i + n ) = ub ( i ) end do ncons = 2 * n else allocate ( C ( 1 , 1 ), icmat ( 1 , 1 ), d ( 1 )) ncons = 0 end if !> QR decomposition of the data matrix. allocate ( Q ( m , n ), source = 0.0_dp ) allocate ( R ( n , n ), source = 0.0_dp ) call qr ( A , Q , R ) !> Compute inv(R). call trtri ( \"u\" , \"n\" , n , R , n , info ) !> Solve the corresponding Quadratic Program. block real ( dp ) :: qvec ( n ), y ( ncons ), obj real ( dp ), allocatable :: work (:) integer :: neq , nact , iter ( 2 ), iact ( ncons ), lwork , r_ ! Prepare variables. neq = 0 ; ncons = n ; r_ = min ( n , ncons ); lwork = 2 * n + r_ * ( r_ + 5 ) / 2 + 2 * ncons + 1 allocate ( work ( lwork ), source = 0.0_dp ) ! Solve QP. info = 1 ; qvec = matmul ( transpose ( A ), b ) call qpgen1 ( R , qvec , n , n , x , y , obj , C , icmat , d , 1 , ncons , & neq , iact , nact , iter , work , info ) end block end procedure bvls end submodule lstsq_variants","tags":"","url":"sourcefile/lstsq_variants.f90.html"},{"title":"drivers.f90 – QuadProg","text":"Source Code !  Copyright (c) 1995-2010 Berwin A. Turlach <berwin.turlach@gmail.com> !  this program is free software; you can redistribute it and/or modify !  it under the terms of the gnu general public license as published by !  the free software foundation; either version 2 of the license, or !  (at your option) any later version. !  this program is distributed in the hope that it will be useful, !  but without any warranty; without even the implied warranty of !  merchantability or fitness for a particular purpose.  see the !  gnu general public license for more details. !  you should have received a copy of the gnu general public license !  along with this program; if not, write to the free software !  foundation, inc., 59 temple place - suite 330, boston, ma 02111-1307, !  usa. submodule ( quadprog ) modernized_drivers implicit none contains !  this routine uses the goldfarb/idnani algorithm to solve the !  following minimization problem: !        minimize  -d&#94;t x + 1/2 *  x&#94;t d x !        where   a1&#94;t x  = b1 !                a2&#94;t x >= b2 !  the matrix d is assumed to be positive definite.  especially, !  w.l.o.g. d is assumed to be symmetric. !  input parameter: !  dmat   nxn matrix, the matrix d from above (dp) !         *** will be destroyed on exit *** !         the user has two possibilities: !         a) give d (ierr=0), in this case we use routines from linpack !            to decompose d. !         b) to get the algorithm started we need r&#94;-1, where d=r&#94;tr. !            so if it is cheaper to calculate r&#94;-1 in another way (d may !            be a band matrix) then with the general routine, the user !            may pass r&#94;{-1}.  indicated by ierr not equal to zero. !  dvec   nx1 vector, the vector d from above (dp) !         *** will be destroyed on exit *** !         contains on exit the solution to the initial, i.e., !         unconstrained problem !  fddmat scalar, the leading dimension of the matrix dmat !  n      the dimension of dmat and dvec (int) !  amat   nxq matrix, the matrix a from above (dp) [ a=(a1 a2)&#94;t ] !         *** entries corresponding to equality constraints may have !             changed signes on exit *** !  bvec   qx1 vector, the vector of constants b in the constraints (dp) !         [ b = (b1&#94;t b2&#94;t)&#94;t ] !         *** entries corresponding to equality constraints may have !             changed signes on exit *** !  fdamat the first dimension of amat as declared in the calling program. !         fdamat >= n !! !  q      integer, the number of constraints. !  meq    integer, the number of equality constraints, 0 <= meq <= q. !  ierr   integer, code for the status of the matrix d: !            ierr =  0, we have to decompose d !            ierr != 0, d is already decomposed into d=r&#94;tr and we were !                       given r&#94;{-1}. !  output parameter: !  sol   nx1 the final solution (x in the notation above) !  lagr  qx1 the final lagrange multipliers !  crval scalar, the value of the criterion at the minimum !  iact  qx1 vector, the constraints which are active in the final !        fit (int) !  nact  scalar, the number of constraints active in the final fit (int) !  iter  2x1 vector, first component gives the number of \"main\" !        iterations, the second one says how many constraints were !        deleted after they became active !  ierr  integer, error code on exit, if !           ierr = 0, no problems !           ierr = 1, the minimization problem has no solution !           ierr = 2, problems with decomposing d, in this case sol !                     contains garbage!! !  working space: !  work  vector with length at least 2*n+r*(r+5)/2 + 2*q +1 !        where r=min(n,q) module procedure qpgen2 integer :: m , n integer :: i , l , l1 , info , it1 , iwzv , iwrv , iwrm , iwsv , iwuv , nvl , r , iwnbv real ( dp ) :: temp , sum , t1 , tt , gc , gs , eps logical :: t1inf , t2min real ( dp ) :: residuals ( size ( At , 2 )) type ( linalg_state_type ) :: err !---------------------------------- !-----     INITIALIZATION     ----- !---------------------------------- n = size ( P , 1 ); m = size ( At , 2 ); r = min ( n , m ) ! Various dimensions. eps = epsilon ( 1.0_dp ) ! Machine precision. call copy ( n , q , 1 , work (: n ), 1 ) ! Store linear component of the objective function. call copy ( n , q , 1 , x , 1 ) ! Copy into the solution array (in-place computations). work ( n + 1 :) = 0.0_dp ; iact = 0 ; y = 0.0_dp ; nact = 0 ; iter = 0 !> Calculate some constants, i.e., from which index on the different !> quantities are stored in the work matrix iwzv = n iwrv = iwzv + n iwuv = iwrv + r iwrm = iwuv + r + 1 iwsv = iwrm + ( r * ( r + 1 )) / 2 iwnbv = iwsv + m !------------------------------------------------------------ !-----     SOLVE UNCONSTRAINED QP AS STARTING POINT     ----- !------------------------------------------------------------ if ( ierr == 0 ) then !> Matrix has not been factorized yet. call cholesky ( P , lower = . false ., other_zeroed = . true .) call trtri ( \"u\" , \"n\" , n , P , n , info ) ! Compute inv(R) from Chol. fact. end if !> Solve unconstrained problem. call trmv ( \"u\" , \"t\" , \"n\" , n , P , n , x , 1 ) ! Multiply by inv(R).T call trmv ( \"u\" , \"n\" , \"n\" , n , P , n , x , 1 ) ! Multiply by inv(R) ierr = 0 !> Evaluate objective function at unconstrained solution. obj = - 0.5_dp * dot_product ( x , work (: n )) !------------------------------------------------------------------------- !-----     ACTIVE SET METHOD FOR SOLVING THE CONSTRAINED PROBLEM     ----- !------------------------------------------------------------------------- !> Calculate the norm of each column of the constraint matrix work ( iwnbv + 1 : iwnbv + m ) = norm ( At , 2 , dim = 1 ) loop50 : do !> Update iteration counter. iter ( 1 ) = iter ( 1 ) + 1 !> Verify all constraints. !>    - Check which are being violated. !>    - For equality ones, the normal vector may have to be negated, b also. call copy ( m , b , 1 , residuals , 1 ) call gemv ( \"t\" , n , m , 1.0_dp , At , n , x , 1 , - 1.0_dp , residuals , 1 ) l = iwsv do i = 1 , m l = l + 1 sum = merge ( residuals ( i ), 0.0_dp , abs ( residuals ( i )) > 0.0_dp ) if ( i > meq ) then work ( l ) = sum else work ( l ) = - abs ( sum ) if ( sum > 0.0_dp ) then call scal ( n , - 1.0_dp , At (:, i ), 1 ) b ( i ) = - b ( i ) end if end if end do !> Active constraints are set explicitly to zero. work ( iwsv + iact ( 1 : nact )) = 0.0_dp !> Select which violated constraint to consider. !>    - Each violation is weighted by the number of non-zero elements in !>      the corresponding row of A. !>    - Selected violated constraint is the one with maximal absolute value. nvl = 0 ; temp = 0.0_dp do i = 1 , m if ( work ( iwsv + i ) < temp * work ( iwnbv + i )) then nvl = i ; temp = work ( iwsv + i ) / work ( iwnbv + i ) end if end do !> If no constraint is being violated, we are optimal. !> Return the vector of Lagrange multipliers and exit. if ( nvl == 0 ) then y ( iact ( 1 : nact )) = work ( iwuv + 1 : iwuv + nact ) return end if !> Compute d = J.T @ n+ !>    -  n+ is the normal vector of the violated constraint. !>    -  J is stored in P in this implementation. !>    -  If a constraint is dropped, we come back here. loop55 : do block700 : block call gemv ( \"t\" , n , n , 1.0_dp , P , n , At (:, nvl ), 1 , 0.0_dp , work (: n ), 1 ) !> Compute z = J_2 @ d_2 l1 = iwzv ; work ( l1 + 1 : l1 + n ) = 0.0_dp call gemv ( \"n\" , n , n - nact , 1.0_dp , P (:, nact + 1 : n ), n , work ( nact + 1 : n ), 1 , 0.0_dp , work ( l1 + 1 : l1 + n ), 1 ) !> Compute r = inv(R) @ d_1 !>    -  Check if r has positive entries (among entries corresponding !>       to inequality constraints). call copy ( nact , work ( 1 : nact ), 1 , work ( iwrv + 1 : iwrv + nact ), 1 ) call tpsv ( \"u\" , \"n\" , \"n\" , nact , work ( iwrm + 1 : iwrm + nact ), work ( iwrv + 1 : iwrv + nact ), 1 ) t1inf = . true . do i = 1 , nact if ( iact ( i ) <= meq ) cycle if ( work ( iwrv + i ) <= 0.0_dp ) cycle t1inf = . false .; it1 = i end do !> If r has positive elements: !>    -  Find partial step length t1 (maximum step in dual space without !>       violating dual feasibility). !>    -  it1 stores wich component t1, the min of u/r, occurs. if (. not . t1inf ) then t1 = work ( iwuv + it1 ) / work ( iwrv + it1 ) do i = 1 , nact if ( iact ( i ) <= meq ) cycle if ( work ( iwrv + i ) <= 0.0_dp ) cycle temp = work ( iwuv + i ) / work ( iwrv + i ) if ( temp < t1 ) then t1 = temp ; it1 = i end if end do end if !> Test if the z vector is equal to zero. sum = norm ( work ( iwzv + 1 : iwzv + n ), 2 ) if ( sum <= eps ) then !> No step in primal space such that the new constraint becomes feasible. !>    -  Take step in dual space and drop a constraint. if ( t1inf ) then !> No step in dual possible is possible. Problem is infeasible. ierr = 1 ; return else !> Take partial step in dual space. !>    -  Drop the it1-th active constraint. !>    -  Continue at step 2(a) (marked by label 55). call axpy ( nact , - t1 , work ( iwrv + 1 : iwrv + nact ), 1 , work ( iwuv + 1 : iwuv + nact ), 1 ) work ( iwuv + nact + 1 ) = work ( iwuv + nact + 1 ) + t1 exit block700 end if else !> Minimum step in primal space such that the constraint becomes feasible. !>    -  Full step length t2. !>    -  Keep sum = z.T @ n+ to update obj below. sum = dot_product ( work ( iwzv + 1 : iwzv + n ), At (:, nvl )) tt = - work ( iwsv + nvl ) / sum ; t2min = . true . if ((. not . t1inf ) . and . ( t1 < tt )) then tt = t1 ; t2min = . false . end if !> Take step in primal and dual space. call axpy ( n , tt , work ( iwzv + 1 : iwzv + n ), 1 , x , 1 ) obj = obj + tt * sum * ( tt / 2.0_dp + work ( iwuv + nact + 1 )) call axpy ( nact , - tt , work ( iwrv + 1 : iwrv + nact ), 1 , work ( iwuv + 1 : iwuv + nact ), 1 ) work ( iwuv + nact + 1 ) = work ( iwuv + nact + 1 ) + tt !> If a full step has been taken: !>    -  Check whether further constraints are violated. !>    -  If not, drop current constraint and iterate once more. if ( t2min ) then !> Full step was performed. !>    -  Add constraint nvl to the list of active constraints. !>    -  Update J and r. nact = nact + 1 ; iact ( nact ) = nvl !> To update r: !>    -  Put the first nact-1 components of the d vector into column !>       nact of r. l = iwrm + (( nact - 1 ) * nact ) / 2 + 1 do i = 1 , nact - 1 work ( l ) = work ( i ); l = l + 1 end do !> If nact = n: !>    -  Add the last element to the new row or r. !> Else: !>    -  Use Given rotations to turn the vector d(nact:n) into a multiple !>       of the first unit vector. !>    -  Multiple goes into the last element of the new row of r. !>    -  J is updated accordingly to the Givens rotations. if ( nact == n ) then work ( l ) = work ( n ) else do i = n , nact + 1 , - 1 !> Find the Givens rotation reducing the l1-th element of d to zero. !> If it is already zero, do nothing except for decreasing l1. if ( work ( i ) == 0.0_dp ) cycle call lartg ( work ( i - 1 ), work ( i ), gc , gs , temp ) !> Givens rotation is done with the matrix [gc gs, gs -gc]. !>    -  If gc = 1, i-th element of d is zero compared with element !>       (l1-1). Hence, do nothing. !>    -  Else, Givens rotation is applied to the columns. The i-1 !>       element of d has to be updated to temp. if ( gc == 1.0_dp ) cycle work ( i - 1 ) = temp call rot ( n , P (:, i - 1 ), 1 , P (:, i ), 1 , gc , gs ) end do !> l is still pointing to element (nact,nact) of the matrix r. !> Store d(nact) in r(nact,nact) work ( l ) = work ( nact ) end if else !> A partial step in dual space was taken. !>    -  Drop the it1-th active constraint. !>    -  Continue to step 2(a) (marked by label 55). !> Since fit changed, we need to recalculate by \"how much\" the chosen !> constraint is now violated. sum = dot_product ( At (:, nvl ), x ) - b ( nvl ) if ( nvl > meq ) then work ( iwsv + nvl ) = sum else work ( iwsv + nvl ) = - abs ( sum ) if ( sum > 0.0_dp ) then call scal ( n , - 1.0_dp , At (:, nvl ), 1 ) b ( nvl ) = - b ( nvl ) end if end if exit block700 end if end if cycle loop50 !> Drop the it1-th constraint. end block block700 !> if it1 = nact !>    -  it is only necessary to update the vector u and nact if ( it1 /= nact ) then ! go to 799 !> After updating one row of r (column of j), come back here. loop797 : do !> Find the Givens rotation reducing the (it1+1, it+1)-th element of R !> to zero. !> If it is already zero: !>    - do nothing except updating u, iact and shifting column (it+1) of R !>      to column (it1). !> l will point ot element (1,it1+1) of R. !> l1 will point to element (it+1, it1+1) of R. ! we have to find the givens rotation which will reduce the element ! (it1+1,it1+1) of r to zero. l = iwrm + ( it1 * ( it1 + 1 )) / 2 + 1 l1 = l + it1 if ( work ( l1 ) /= 0.0_dp ) then ! first go to 798 call lartg ( work ( l1 - 1 ), work ( l1 ), gc , gs , temp ) !> Givens rotation is done with the matrix [gc gc ; gs -gc]. !> If gc = 0: !>    - Switch row (it1) and (it1+1) of R !>    - Switch column (it1= and (it+1) of J. !>    - Since we switch rows in R and columns R, we can ignore sign(gs). !> Else: !>    - Apply Givens rotation to these rows/columns. if ( gc /= 1.0_dp ) then ! second go to 798 if ( gc == 0.0_dp ) then do i = it1 + 1 , nact temp = work ( l1 - 1 ) work ( l1 - 1 ) = work ( l1 ) work ( l1 ) = temp l1 = l1 + i end do call swap ( n , P (:, it1 ), 1 , P (:, it1 + 1 ), 1 ) else do i = it1 + 1 , nact temp = gc * work ( l1 - 1 ) + gs * work ( l1 ) work ( l1 ) = gc * work ( l1 ) - gs * work ( l1 - 1 ) work ( l1 - 1 ) = temp l1 = l1 + i end do call rot ( n , P (:, it1 ), 1 , P (:, it1 + 1 ), 1 , gc , gs ) end if ! shift column (it1+1) of r to column (it1) (that is, the first it1 ! elements). the posit1on of element (1,it1+1) of r was calculated above ! and stored in l. end if end if l1 = l - it1 ; call copy ( it1 , work ( l : l + it1 ), 1 , work ( l1 : l1 + it1 ), 1 ) !> Update vector u and iact as necessary and continue !> with updating the matrices J and R. work ( iwuv + it1 ) = work ( iwuv + it1 + 1 ) iact ( it1 ) = iact ( it1 + 1 ) it1 = it1 + 1 if ( it1 >= nact ) exit loop797 end do loop797 end if ! go to 799 work ( iwuv + nact ) = work ( iwuv + nact + 1 ) work ( iwuv + nact + 1 ) = 0.0_dp iact ( nact ) = 0 nact = nact - 1 iter ( 2 ) = iter ( 2 ) + 1 end do loop55 end do loop50 return end procedure qpgen2 !  this routine uses the goldfarb/idnani algorithm to solve the !  following minimization problem: !        minimize  -d&#94;t x + 1/2 *  x&#94;t d x !        where   a1&#94;t x  = b1 !                a2&#94;t x >= b2 !  the matrix d is assumed to be positive definite.  especially, !  w.l.o.g. d is assumed to be symmetric. !  input parameter: !  dmat   nxn matrix, the matrix d from above (dp) !         *** will be destroyed on exit *** !         the user has two possibilities: !         a) give d (ierr=0), in this case we use routines from linpack !            to decompose d. !         b) to get the algorithm started we need r&#94;-1, where d=r&#94;tr. !            so if it is cheaper to calculate r&#94;-1 in another way (d may !            be a band matrix) then with the general routine, the user !            may pass r&#94;{-1}.  indicated by ierr not equal to zero. !  dvec   nx1 vector, the vector d from above (dp) !         *** will be destroyed on exit *** !         contains on exit the solution to the initial, i.e., !         unconstrained problem !  fddmat scalar, the leading dimension of the matrix dmat !  n      the dimension of dmat and dvec (int) !  amat   lxq matrix (dp) !         *** entries corresponding to equality constraints may have !             changed signes on exit *** !  iamat  (l+1)xq matrix (int) !         these two matrices store the matrix a in compact form. the format !         is: [ a=(a1 a2)&#94;t ] !           iamat(1,i) is the number of non-zero elements in column i of a !           iamat(k,i) for k>=2, is equal to j if the (k-1)-th non-zero !                      element in column i of a is a(i,j) !            amat(k,i) for k>=1, is equal to the k-th non-zero element !                      in column i of a. !  bvec   qx1 vector, the vector of constants b in the constraints (dp) !         [ b = (b1&#94;t b2&#94;t)&#94;t ] !         *** entries corresponding to equality constraints may have !             changed signes on exit *** !  fdamat the first dimension of amat as declared in the calling program. !         fdamat >= n (and iamat must have fdamat+1 as first dimension) !  q      integer, the number of constraints. !  meq    integer, the number of equality constraints, 0 <= meq <= q. !  ierr   integer, code for the status of the matrix d: !            ierr =  0, we have to decompose d !            ierr != 0, d is already decomposed into d=r&#94;tr and we were !                       given r&#94;{-1}. !  output parameter: !  sol   nx1 the final solution (x in the notation above) !  lagr  qx1 the final lagrange multipliers !  crval scalar, the value of the criterion at the minimum !  iact  qx1 vector, the constraints which are active in the final !        fit (int) !  nact  scalar, the number of constraints active in the final fit (int) !  iter  2x1 vector, first component gives the number of \"main\" !        iterations, the second one says how many constraints were !        deleted after they became active !  ierr  integer, error code on exit, if !           ierr = 0, no problems !           ierr = 1, the minimization problem has no solution !           ierr = 2, problems with decomposing d, in this case sol !                     contains garbage!! !  working space: !  work  vector with length at least 2*n+r*(r+5)/2 + 2*q +1 !        where r=min(n,q) module procedure qpgen1 integer :: i , j , l , l1 , info , it1 , iwzv , iwrv , iwrm , iwsv , iwuv , nvl , r , iwnbv real ( dp ) :: temp , sum , t1 , tt , gc , gs , nu , vsmall logical :: t1inf , t2min type ( linalg_state_type ) :: err r = min ( n , q ) l = 2 * n + ( r * ( r + 5 )) / 2 + 2 * q + 1 vsmall = epsilon ( 1.0_dp ) !> Store the initial dvec and initialize some arrays. call copy ( n , dvec ( 1 : n ), 1 , work ( 1 : n ), 1 ) work ( n + 1 : l ) = 0.0_dp ; iact ( 1 : q ) = 0 ; lagr ( 1 : q ) = 0.0_dp !------------------------------------------------------------ !-----     SOLVE UNCONSTRAINED QP AS STARTING POINT     ----- !------------------------------------------------------------ if ( ierr == 0 ) then !> Matrix has not been factorized yet. call cholesky ( dmat (: n , : n ), lower = . false ., other_zeroed = . true .) call trtri ( \"u\" , \"n\" , n , dmat , n , info ) ! Compute inv(R) from Chol. fact. end if !> Matrix has already been pre-factorized by calling dpofa and dpori. !> Multiply by inv(R).T call trmv ( \"u\" , \"t\" , \"n\" , n , dmat , n , dvec , 1 ) !> Multiply by inv(R). call trmv ( \"u\" , \"n\" , \"n\" , n , dmat , n , dvec , 1 ) !> Book-keeping: !>    - set lower triangular part of dmat to zero, !>    - store dvec in sol, !>    - calculate value of the criterion at unconstrained minima do concurrent ( i = 1 : n , j = 1 : n ) if ( i > j ) dmat ( i , j ) = 0.0_dp end do call copy ( n , dvec ( 1 : n ), 1 , sol ( 1 : n ), 1 ) crval = - 0.5_dp * dot_product ( sol ( 1 : n ), work ( 1 : n )) ierr = 0 !> Calculate some constants, i.e., from which index on the different !> quantities are stored in the work matrix iwzv = n iwrv = iwzv + n iwuv = iwrv + r iwrm = iwuv + r + 1 iwsv = iwrm + ( r * ( r + 1 )) / 2 iwnbv = iwsv + q !> Calculate the norm of each column of the constraint matrix do i = 1 , q work ( iwnbv + i ) = norm ( amat ( 1 : fdamat , i ), 2 ) end do nact = 0 iter ( 1 ) = 0 iter ( 2 ) = 0 !------------------------------------------------------------------------- !-----     ACTIVE SET METHOD FOR SOLVING THE CONSTRAINED PROBLEM     ----- !------------------------------------------------------------------------- loop50 : do !> Update iteration counter. iter ( 1 ) = iter ( 1 ) + 1 !> Verify all constraints. !>    - Check which are being violated. !>    - For equality ones, the normal vector may have to be negated, bvec also. l = iwsv do i = 1 , q l = l + 1 sum = - bvec ( i ) do j = 1 , iamat ( 1 , i ) sum = sum + amat ( j , i ) * sol ( iamat ( j + 1 , i )) end do if ( abs ( sum ) < vsmall ) sum = 0.0_dp if ( i > meq ) then work ( l ) = sum else work ( l ) = - abs ( sum ) if ( sum > 0.0_dp ) then call scal ( fdamat , - 1.0_dp , amat ( 1 : fdamat , i ), 1 ) bvec ( i ) = - bvec ( i ) end if end if end do !> Active constraints are set explicitly to zero. do i = 1 , nact work ( iwsv + iact ( i )) = 0.0_dp end do !> Select which violated constraint to consider. !>    - Each violation is weighted by the number of non-zero elements in !>      the corresponding row of A. !>    - Selected violated constraint is the one with maximal absolute value. nvl = 0 temp = 0.0_dp do i = 1 , q if ( work ( iwsv + i ) < temp * work ( iwnbv + i )) then nvl = i temp = work ( iwsv + i ) / work ( iwnbv + i ) end if end do if ( nvl == 0 ) then lagr ( iact ( 1 : nact )) = work ( iwuv + 1 : iwuv + nact ) return end if !> Compute d = J.T @ n+ !>    -  n+ is the normal vector of the violated constraint. !>    -  J is stored in dmat in this implementation. !>    -  If a constraint is dropped, we come back here. loop55 : do block700 : block do i = 1 , n sum = 0.0_dp do j = 1 , iamat ( 1 , nvl ) sum = sum + dmat ( iamat ( j + 1 , nvl ), i ) * amat ( j , nvl ) end do work ( i ) = sum end do !> Compute z = J_2 @ d_2 l1 = iwzv work ( l1 + 1 : l1 + n ) = 0.0_dp call gemv ( \"n\" , n , n - nact , 1.0_dp , dmat ( 1 : n , nact + 1 : n ), n , & work ( nact + 1 : n ), 1 , 0.0_dp , work ( l1 + 1 : l1 + n ), 1 ) !> Compute r = inv(R) @ d_1 !>    -  Check if r has positive entries (among entries corresponding !>       to inequality constraints). t1inf = . true . do i = nact , 1 , - 1 sum = work ( i ) l = iwrm + ( i * ( i + 3 )) / 2 l1 = l - i do j = i + 1 , nact sum = sum - work ( l ) * work ( iwrv + j ) l = l + j end do sum = sum / work ( l1 ) work ( iwrv + i ) = sum if ( iact ( i ) <= meq ) cycle if ( sum <= 0.0_dp ) cycle t1inf = . false . it1 = i end do !> If r has positive elements: !>    -  Find partial step length t1 (maximum step in dual space without !>       violating dual feasibility). !>    -  it1 stores wich component t1, the min of u/r, occurs. if (. not . t1inf ) then t1 = work ( iwuv + it1 ) / work ( iwrv + it1 ) do i = 1 , nact if ( iact ( i ) <= meq ) cycle if ( work ( iwrv + i ) <= 0.0_dp ) cycle temp = work ( iwuv + i ) / work ( iwrv + i ) if ( temp < t1 ) then t1 = temp it1 = i end if end do end if !> Test if the z vector is equal to zero. sum = norm ( work ( iwzv + 1 : iwzv + n ), 2 ) if ( sum <= vsmall ) then !> No step in primal space such that the new constraint becomes feasible. !>    -  Take step in dual space and drop a constraint. if ( t1inf ) then !> No step in dual possible is possible. Problem is infeasible. ierr = 1 ; return else !> Take partial step in dual space. !>    -  Drop the it1-th active constraint. !>    -  Continue at step 2(a) (marked by label 55). call axpy ( nact , - t1 , work ( iwrv + 1 : iwrv + nact ), 1 , & work ( iwuv + 1 : iwuv + nact ), 1 ) work ( iwuv + nact + 1 ) = work ( iwuv + nact + 1 ) + t1 exit block700 end if else !> Minimum step in primal space such that the constraint becomes feasible. !>    -  Full step length t2. !>    -  Keep sum = z.T @ n+ to update crval below. sum = 0.0_dp do i = 1 , iamat ( 1 , nvl ) sum = sum + work ( iwzv + iamat ( i + 1 , nvl )) * amat ( i , nvl ) end do tt = - work ( iwsv + nvl ) / sum t2min = . true . if (. not . t1inf ) then if ( t1 < tt ) then tt = t1 t2min = . false . end if end if !> Take step in primal and dual space. call axpy ( n , tt , work ( iwzv + 1 : iwzv + n ), 1 , sol ( 1 : n ), 1 ) crval = crval + tt * sum * ( tt / 2.0_dp + work ( iwuv + nact + 1 )) call axpy ( nact , - tt , work ( iwrv + 1 : iwrv + nact ), 1 , & work ( iwuv + 1 : iwuv + nact ), 1 ) work ( iwuv + nact + 1 ) = work ( iwuv + nact + 1 ) + tt !> If a full step has been taken: !>    -  Check whether further constraints are violated. !>    -  If not, drop current constraint and iterate once more. if ( t2min ) then !> Full step was performed. !>    -  Add constraint nvl to the list of active constraints. !>    -  Update J and r. nact = nact + 1 iact ( nact ) = nvl !> To update r: !>    -  Put the first nact-1 components of the d vector into column !>       nact of r. l = iwrm + (( nact - 1 ) * nact ) / 2 + 1 do i = 1 , nact - 1 work ( l ) = work ( i ) l = l + 1 end do !> If nact = n: !>    -  Add the last element to the new row or r. !> Else: !>    -  Use Given rotations to turn the vector d(nact:n) into a multiple !>       of the first unit vector. !>    -  Multiple goes into the last element of the new row of r. !>    -  J is updated accordingly to the Givens rotations. if ( nact == n ) then work ( l ) = work ( n ) else do i = n , nact + 1 , - 1 !> Find the Givens rotation reducing the l1-th element of d to zero. !> If it is already zero, do nothing except for decreasing l1. if ( work ( i ) == 0.0_dp ) cycle call lartg ( work ( i - 1 ), work ( i ), gc , gs , temp ) !> Givens rotation is done with the matrix [gc gs, gs -gc]. !>    -  If gc = 1, i-th element of d is zero compared with element !>       (l1-1). Hence, do nothing. !>    -  Else, Givens rotation is applied to the columns. The i-1 !>       element of d has to be updated to temp. if ( gc == 1.0_dp ) cycle work ( i - 1 ) = temp call rot ( n , dmat ( 1 : n , i - 1 ), 1 , dmat ( 1 : n , i ), 1 , gc , gs ) end do !> l is still pointing to element (nact,nact) of the matrix r. !> Store d(nact) in r(nact,nact) work ( l ) = work ( nact ) end if else !> A partial step in dual space was taken. !>    -  Drop the it1-th active constraint. !>    -  Continue to step 2(a) (marked by label 55). !> Since fit changed, we need to recalculate by \"how much\" the chosen !> constraint is now violated. sum = - bvec ( nvl ) do j = 1 , iamat ( 1 , nvl ) sum = sum + sol ( iamat ( j + 1 , nvl )) * amat ( j , nvl ) end do if ( nvl > meq ) then work ( iwsv + nvl ) = sum else work ( iwsv + nvl ) = - abs ( sum ) if ( sum > 0.0_dp ) then do j = 1 , iamat ( 1 , nvl ) amat ( j , nvl ) = - amat ( j , nvl ) end do bvec ( nvl ) = - bvec ( nvl ) end if end if exit block700 end if end if cycle loop50 !> Drop the it1-th constraint. end block block700 !> if it1 = nact !>    -  it is only necessary to update the vector u and nact if ( it1 /= nact ) then !> After updating one row of r (column of j), come back here. loop797 : do !> Find the Givens rotation reducing the (it1+1, it+1)-th element of R !> to zero. !> If it is already zero: !>    - do nothing except updating u, iact and shifting column (it+1) of R !>      to column (it1). !> l will point ot element (1,it1+1) of R. !> l1 will point to element (it+1, it1+1) of R. ! we have to find the givens rotation which will reduce the element ! (it1+1,it1+1) of r to zero. l = iwrm + ( it1 * ( it1 + 1 )) / 2 + 1 l1 = l + it1 if ( work ( l1 ) /= 0.0_dp ) then gc = max ( abs ( work ( l1 - 1 )), abs ( work ( l1 ))) gs = min ( abs ( work ( l1 - 1 )), abs ( work ( l1 ))) temp = sign ( gc * sqrt ( 1 + ( gs / gc ) * ( gs / gc )), work ( l1 - 1 )) gc = work ( l1 - 1 ) / temp gs = work ( l1 ) / temp !> Givens rotation is done with the matrix [gc gc ; gs -gc]. !> If gc = 0: !>    - Switch row (it1) and (it1+1) of R !>    - Switch column (it1= and (it+1) of J. !>    - Since we switch rows in R and columns R, we can ignore sign(gs). !> Else: !>    - Apply Givens rotation to these rows/columns. if ( gc /= 1.0_dp ) then if ( gc == 0.0_dp ) then do i = it1 + 1 , nact temp = work ( l1 - 1 ) work ( l1 - 1 ) = work ( l1 ) work ( l1 ) = temp l1 = l1 + i end do do i = 1 , n temp = dmat ( i , it1 ) dmat ( i , it1 ) = dmat ( i , it1 + 1 ) dmat ( i , it1 + 1 ) = temp end do else nu = gs / ( 1.0_dp + gc ) do i = it1 + 1 , nact temp = gc * work ( l1 - 1 ) + gs * work ( l1 ) work ( l1 ) = nu * ( work ( l1 - 1 ) + temp ) - work ( l1 ) work ( l1 - 1 ) = temp l1 = l1 + i end do do i = 1 , n temp = gc * dmat ( i , it1 ) + gs * dmat ( i , it1 + 1 ) dmat ( i , it1 + 1 ) = nu * ( dmat ( i , it1 ) + temp ) - dmat ( i , it1 + 1 ) dmat ( i , it1 ) = temp end do end if ! shift column (it1+1) of r to column (it1) (that is, the first it1 ! elements). the posit1on of element (1,it1+1) of r was calculated above ! and stored in l. end if end if l1 = l - it1 do i = 1 , it1 work ( l1 ) = work ( l ) l = l + 1 l1 = l1 + 1 end do !> Update vector u and iact as necessary and continue !> with updating the matrices J and R. work ( iwuv + it1 ) = work ( iwuv + it1 + 1 ) iact ( it1 ) = iact ( it1 + 1 ) it1 = it1 + 1 if ( it1 >= nact ) exit loop797 end do loop797 end if work ( iwuv + nact ) = work ( iwuv + nact + 1 ) work ( iwuv + nact + 1 ) = 0.0_dp iact ( nact ) = 0 nact = nact - 1 iter ( 2 ) = iter ( 2 ) + 1 end do loop55 end do loop50 return end procedure qpgen1 end submodule modernized_drivers","tags":"","url":"sourcefile/drivers.f90.html"},{"title":"Overview – QuadProg","text":"Warning This page is under construction","tags":"","url":"page/index.html"},{"title":"Examples – QuadProg","text":"","tags":"","url":"page/examples/index.html"}]}